:NewDefs



trait A
trait B
//│ trait A
//│ trait B

module AA extends A, B
//│ module AA extends A, B

fun x: A & B
fun x = AA
//│ fun x: AA
//│ fun x: A & B

x : A
//│ A
//│ res
//│     = AA { class: [class AA extends Object] }



abstract class Foo[A, B] { fun x: A & B }
//│ abstract class Foo[A, B] {
//│   fun x: A & B
//│ }

module Bar extends Foo[Int, Bool] { fun x = x }
//│ module Bar extends Foo {
//│   fun x: nothing
//│ }

module Bar extends Foo { fun x = () }
//│ module Bar extends Foo {
//│   fun x: ()
//│ }

Bar : Foo['a, 'b]
//│ Foo['a, 'b]
//│   where
//│     'b :> ()
//│     'a :> ()
//│ res
//│     = Bar { class: [class Bar extends Foo] }


// * An overloaded function type
fun f: (Int -> Int) & (Bool -> Bool)
fun f = id
//│ fun f: forall 'a. 'a -> 'a
//│ fun f: Int -> Int & Bool -> Bool


// * Widen the results
fun h: (Int -> (Int | Bool)) & (Bool -> (Int | Bool))
fun h = f
//│ fun h: Int -> Int & Bool -> Bool
//│ fun h: (Int | false | true) -> (Int | false | true)

// * Merge intersected functions with same domain
fun g: (Int | Bool) -> (Int | Bool)
fun g = h
//│ fun g: (Int | false | true) -> (Int | false | true)
//│ fun g: (Int | false | true) -> (Int | false | true)

// * In one step
:e // TODO: argument of union type
fun g: (Int | Bool) -> (Int | Bool)
fun g = f
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.71: 	fun g = f
//│ ║        	    ^^^^^
//│ ╟── type `Int -> Int & Bool -> Bool` is not a function
//│ ║  l.50: 	fun f: (Int -> Int) & (Bool -> Bool)
//│ ║        	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(Int | false | true) -> (Int | false | true)`
//│ ║  l.71: 	fun g = f
//│ ║        	        ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.70: 	fun g: (Int | Bool) -> (Int | Bool)
//│ ╙──      	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ fun g: Int -> Int & Bool -> Bool
//│ fun g: (Int | false | true) -> (Int | false | true)


// * Can also widen into intersection
fun i: ((Int & Bool) -> Int) & ((Int & Bool) -> Bool)
fun i = f
//│ fun i: Int -> Int & Bool -> Bool
//│ fun i: nothing -> nothing

// * Merge intersected functions with same codomain
fun j: (Int & Bool) -> (Int & Bool)
fun j = i
//│ fun j: nothing -> nothing
//│ fun j: nothing -> nothing

:e // * Note: currently it doesn't work when done in a single step
fun j: (Int & Bool) -> (Int & Bool)
fun j = f
//│ ╔══[ERROR] Type mismatch in definition:
//│ ║  l.102: 	fun j = f
//│ ║         	    ^^^^^
//│ ╟── type `Int -> Int & Bool -> Bool` is not a function
//│ ║  l.50: 	fun f: (Int -> Int) & (Bool -> Bool)
//│ ║        	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `nothing -> nothing`
//│ ║  l.102: 	fun j = f
//│ ║         	        ^
//│ ╟── Note: constraint arises from function type:
//│ ║  l.101: 	fun j: (Int & Bool) -> (Int & Bool)
//│ ╙──       	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ fun j: Int -> Int & Bool -> Bool
//│ fun j: nothing -> nothing


// * Or widen even further with both an intersection and a union, into this
fun g: (Int & Bool) -> (Int | Bool)
fun g = f
//│ fun g: Int -> Int & Bool -> Bool
//│ fun g: nothing -> (Int | false | true)


// * Note: we currently approximate uses of overloaded function types!
// * With match-type-based constraint solving, we could return Int here

f(0)
//│ Int
//│ res
//│     = 0

// f(0) : case 0 of { Int => Int; Bool => Bool } == Int


x => f(x)
//│ forall 'a 'b. 'a -> 'b
//│   where
//│     [+'a, -'b] in {[Int, Int], [Bool, Bool]}
//│ res
//│     = [Function: res]

// : forall 'a: 'a -> case 'a of { Int => Int; Bool => Bool } where 'a <: Int | Bool

:e
f(if true then 0 else false)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.147: 	f(if true then 0 else false)
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int -> Int & Bool -> Bool` is not a function
//│ ║  l.50: 	fun f: (Int -> Int) & (Bool -> Bool)
//│ ║        	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `(0 | false) -> ?a`
//│ ║  l.147: 	f(if true then 0 else false)
//│ ╙──       	^
//│ error
//│ res
//│     = 0

// * With match-type-based constraint solving, we could *also* return Int here

:e // TODO implement this syntax
:w
f(refined if true then 0 else false) // this one can be precise again!
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.165: 	f(refined if true then 0 else false) // this one can be precise again!
//│ ╙──       	  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Illegal use of reserved operator: refined
//│ ║  l.165: 	f(refined if true then 0 else false) // this one can be precise again!
//│ ╙──       	  ^^^^^^^
//│ ╔══[ERROR] identifier not found: refined
//│ ║  l.165: 	f(refined if true then 0 else false) // this one can be precise again!
//│ ╙──       	  ^^^^^^^
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.165: 	f(refined if true then 0 else false) // this one can be precise again!
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── type `Int -> Int & Bool -> Bool` is not a function
//│ ║  l.50: 	fun f: (Int -> Int) & (Bool -> Bool)
//│ ║        	       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `?a -> ?b`
//│ ║  l.165: 	f(refined if true then 0 else false) // this one can be precise again!
//│ ╙──       	^
//│ 'a
//│   where
//│     'a :> error
//│     [+'b, -'a] in {}
//│ Code generation encountered an error:
//│   unresolved symbol refined



// * Notes on constraint solving


// * Easy:

// ?a -> ?b <: (Int -> Int) & (Bool -> Bool)
// to:
// ?a -> ?b <: (Int -> Int) AND ?a -> ?b <: (Bool -> Bool)

// * Hard; but can solve with match types:

// (Int -> Int) & (Bool -> Bool) <: ?a -> ?b
// to:
// ?a <: Int | Bool AND (case ?a of { Int => Int; Bool => Bool }) <: ?b

// We can still widen if needed; consider:
// ?a := Int | Bool
// then:
// (case (Int | Bool) of { Int => Int; Bool => Bool }) <: ?b
// to:
// Int <: ?b AND Bool <: ?b

// An simple match-type constraint example:
// (case ?a of { Int => Int; Bool => Bool }) <: Int
// to:
// ?a <: Int

// A more complicated match-type constraint example:
// (case ?a of { Int => ?b; Bool => ?c }) <: T
// to:
// ?b <: (case ?a of { Int => T; Bool => Top }) AND ?c <: (case ?a of { Int => Top; Bool => T })



class List[A]
//│ class List[A] {
//│   constructor()
//│ }

// * Note: match type `T match { case List[t] => ... t ... }` could be encoded as:

type M = (forall 't: List['t] => 't)
//│ type M = forall 't. List['t] -> 't

type T = List[Int]
//│ type T = List[Int]

:e // TODO application types
type Res = M(T)
//│ ╔══[ERROR] Wrong number of type arguments – expected 0, found 1
//│ ║  l.241: 	type Res = M(T)
//│ ╙──       	           ^^^^
//│ type Res = M



let f = x => [x, x]
//│ let f: forall 'a. 'a -> ['a, 'a]
//│ f
//│   = [Function: f1]

[f(1), f(true)]
//│ [[1, 1], [true, true]]
//│ res
//│     = [ [ 1, 1 ], [ true, true ] ]



:e // TODO support
fun f: Int -> Int
fun f: Bool -> Bool
fun f = id
//│ ╔══[ERROR] A type signature for 'f' was already given
//│ ║  l.263: 	fun f: Bool -> Bool
//│ ╙──       	^^^^^^^^^^^^^^^^^^^
//│ fun f: forall 'a. 'a -> 'a
//│ fun f: Int -> Int

:e // TODO support
f: (Int -> Int) & (Bool -> Bool)
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.272: 	f: (Int -> Int) & (Bool -> Bool)
//│ ║         	^
//│ ╟── type `Bool` is not an instance of type `Int`
//│ ║  l.272: 	f: (Int -> Int) & (Bool -> Bool)
//│ ║         	                   ^^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.262: 	fun f: Int -> Int
//│ ╙──       	       ^^^
//│ Int -> Int & Bool -> Bool
//│ res
//│     = [Function: id]

//   t: S  t: T
// -------------
//   t: S & T



// * Weird MLstruct rule (only sound when we don't have FCP):
// forall 'a: 'a -> 'a <: (Int -> Int) & (Bool -> Bool) == (Int | Bool) -> (Int & Bool)
// ~{ a: Int } <: Str -> Str

// * Notice: in positive position, this is equivalent to Bottom
fun x: ~{ a: Int }
//│ fun x: ~{a: Int}


class A()
class B()
//│ class A()
//│ class B()

A() : ~B
//│ ~B
//│ res
//│     = A {}

// A <: ~B
// <=>
// A <: ~B | Bot
// <=>
// A & B <: Bot

fun x: A & B
//│ fun x: nothing


fun test(x) = if x is
  A then 0
  _ then x
//│ fun test: forall 'a. (A | Object & 'a & ~#A) -> (0 | 'a)

test(B())
//│ 0 | B
//│ res
//│     = B {}

test(A())
//│ 0
//│ res
//│     = 0

// A <: A | Object & 'a & ~A
// A & ~A <: Object & 'a & ~A
// Bot <: Object & 'a & ~A


:e // TODO implement this syntax
:w
fun test(x) = refined if x is
  A then 0
  B then 1
//│ ╔══[WARNING] Paren-less applications should use the 'of' keyword
//│ ║  l.343: 	fun test(x) = refined if x is
//│ ║         	              ^^^^^^^^^^^^^^^
//│ ║  l.344: 	  A then 0
//│ ║         	^^^^^^^^^^
//│ ║  l.345: 	  B then 1
//│ ╙──       	^^^^^^^^^^
//│ ╔══[ERROR] Illegal use of reserved operator: refined
//│ ║  l.343: 	fun test(x) = refined if x is
//│ ╙──       	              ^^^^^^^
//│ ╔══[ERROR] identifier not found: refined
//│ ║  l.343: 	fun test(x) = refined if x is
//│ ╙──       	              ^^^^^^^
//│ fun test: (A | B) -> error
//│ Code generation encountered an error:
//│   unresolved symbol refined

// forall 'a: 'a -> (case 'a of A -> 0, B & ~A -> 1)



fun q: (0|1) -> true & (1|2) -> false
//│ fun q: (0 | 1) -> true & (1 | 2) -> false

q(0)
//│ true
//│ res
//│     = <no result>
//│       q is not implemented

q(0) : true
//│ true
//│ res
//│     = <no result>
//│       q is not implemented

q(1)
//│ 'a
//│   where
//│     [-'a] in {[true], [false]}
//│ res
//│     = <no result>
//│       q is not implemented

q(1) : Bool
//│ Bool
//│ res
//│     = <no result>
//│       q is not implemented

x => q(x): true
//│ (0 | 1) -> true
//│ res
//│     = <no result>
//│       q is not implemented

x => q(x)
//│ forall 'a 'b. 'a -> 'b
//│   where
//│     [+'a, -'b] in {[0 | 1, true], [1 | 2, false]}
//│ res
//│     = <no result>
//│       q is not implemented

fun w = x => q(x)
//│ fun w: forall 'a 'b. 'a -> 'b
//│   where
//│     [+'a, -'b] in {[0 | 1, true], [1 | 2, false]}

w(0)
//│ true
//│ res
//│     = <no result>
//│       w and q are not implemented

x => (f: forall a: ((0, Int) -> 'a & (1, Str) -> ['a])) => f(0, x) + 1
//│ Int -> (f: (0, Int) -> Int & (1, Str) -> [Int]) -> Int
//│ res
//│     = [Function: res]

fun r: Int -> Int & Bool -> Bool
//│ fun r: Int -> Int & Bool -> Bool

:e
x => r(r(x))
//│ ╔══[ERROR] ambiguous
//│ ╟── cannot determine satisfiability of type ?a
//│ ║  l.430: 	x => r(r(x))
//│ ╙──       	       ^^^^
//│ forall 'a 'b. 'a -> 'b
//│   where
//│     [-'b, +'c] in {[Int, Int], [Bool, Bool]}
//│     [-'c, +'a] in {[Int, Int], [Bool, Bool]}
//│ res
//│     = <no result>
//│       r is not implemented


r(r(0))
//│ Int
//│ res
//│     = <no result>
//│       r is not implemented

x => r(r(x))+1
//│ Int -> Int
//│ res
//│     = <no result>
//│       r is not implemented

fun u: {x:0, y:Int} -> Int & {x:1, z: Str} -> Str
//│ fun u: {x: 0, y: Int} -> Int & {x: 1, z: Str} -> Str

(a, b, c) => u({x: a, y: b, z: c})
//│ forall 'a 'b 'c 'd. ('a, 'c, 'd) -> 'b
//│   where
//│     [-'b, +'c, +'a, +'d] in {[Int, Int, 0, anything], [Str, anything, 1, Str]}
//│ res
//│     = <no result>
//│       u is not implemented

(a, b) => u({x: a, y: "abc", z: b})
//│ (1, Str) -> Str
//│ res
//│     = <no result>
//│       u is not implemented

fun s: Str -> Str & AA -> AA
//│ fun s: Str -> Str & AA -> AA

// FIXME
let g = x => s(r(x))
//│ let g: forall 'a 'b. 'a -> 'b
//│   where
//│     [-'b, +'c] in {[Str, Str], [AA, AA]}
//│     [+'a, -'c] in {[Int, Int], [Bool, Bool]}
//│ g
//│   = <no result>
//│     s is not implemented

:e
g(0)
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.487: 	g(0)
//│ ║         	^^^^
//│ ╟── integer literal of type `Int` does not match type `?a`
//│ ║  l.487: 	g(0)
//│ ║         	  ^
//│ ╟── Note: constraint arises from application:
//│ ║  l.477: 	let g = x => s(r(x))
//│ ╙──       	               ^^^^
//│ error
//│ res
//│     = <no result>
//│       g and s are not implemented

fun rt: {0: Int} -> Int & {0: Str} -> Str
//│ fun rt: {0: Int} -> Int & {0: Str} -> Str

rt([1,"str"])
//│ Int
//│ res
//│     = <no result>
//│       rt is not implemented

rt(["str",1])
//│ Str
//│ res
//│     = <no result>
//│       rt is not implemented

fun app2: ('a -> 'a -> 'a) -> 'a -> 'a
//│ fun app2: forall 'a. ('a -> 'a -> 'a) -> 'a -> 'a

fun snd: A -> Int -> Int & Str -> Str -> Str
//│ fun snd: A -> Int -> Int & Str -> Str -> Str

:e
x => app2(snd)(x):Int
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.524: 	x => app2(snd)(x):Int
//│ ║         	     ^^^^^^^^^^^^
//│ ╟── application of type `Int` is not an instance of type `A`
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.520: 	fun snd: A -> Int -> Int & Str -> Str -> Str
//│ ║         	         ^
//│ ╟── from type reference:
//│ ║  l.524: 	x => app2(snd)(x):Int
//│ ╙──       	                  ^^^
//│ nothing -> Int
//│ res
//│     = <no result>
//│       app2 is not implemented

fun app2_ (f:'a -> 'a -> 'a)(x) = f(x)(x)
//│ fun app2_: forall 'a. (f: 'a -> 'a -> 'a) -> 'a -> 'a

app2_(snd)
//│ 'a -> 'b
//│   where
//│     'a <: 'b
//│     [-'b, +'a, -'a] in {[Int, A & Int, Int], [Str, Str, Str]}
//│ res
//│     = <no result>
//│       snd is not implemented
